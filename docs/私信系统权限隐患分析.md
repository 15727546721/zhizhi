# 私信系统权限隐患分析

## 概述

本文档分析了当前私信系统的权限隐患，并提供了解决方案建议。

## 发现的权限隐患

### 1. 用户状态检查缺失 ⚠️ **高危**

**问题描述**：
- 发送私信时没有检查发送者的账号状态（是否被封禁、待审核）
- 没有检查接收者的账号状态（是否被封禁、已删除）

**风险**：
- 被封禁的用户仍然可以发送私信
- 已删除的用户可能收到消息
- 待审核的用户可以发送私信

**影响范围**：
- 所有私信发送接口

**解决方案**：
在 `PrivateMessageDomainService.sendPrivateMessage()` 方法中添加用户状态检查：

```java
// 1. 检查发送者状态
UserEntity sender = userService.getUserById(senderId);
sender.validateCanPerformAction(); // 检查是否被封禁

// 2. 检查接收者状态
UserEntity receiver = userService.getUserById(receiverId);
if (receiver.isBanned() || receiver.isPending()) {
    throw new BusinessException("接收者账号异常，无法接收消息");
}
```

---

### 2. 用户隐私设置缺失 ⚠️ **中危**

**问题描述**：
- 没有用户级别的私信权限设置
- 用户无法设置"只接收互相关注用户的私信"
- 用户无法完全关闭私信功能

**风险**：
- 用户无法主动控制谁可以给自己发私信
- 只能通过屏蔽来阻止，但需要屏蔽每个用户，不够灵活

**影响范围**：
- 用户体验
- 隐私保护

**解决方案**：
创建用户私信设置表：

```sql
CREATE TABLE `user_message_settings` (
  `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '设置ID',
  `user_id` BIGINT UNSIGNED NOT NULL COMMENT '用户ID',
  `allow_stranger_message` TINYINT NOT NULL DEFAULT 1 COMMENT '是否允许陌生人私信：0-不允许 1-允许',
  `allow_non_mutual_follow_message` TINYINT NOT NULL DEFAULT 1 COMMENT '是否允许非互相关注用户私信：0-不允许 1-允许',
  `message_notification_enabled` TINYINT NOT NULL DEFAULT 1 COMMENT '是否开启私信通知：0-关闭 1-开启',
  `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_user_id` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户私信设置表';
```

在发送私信时检查接收者的设置：

```java
// 检查接收者的私信设置
UserMessageSettings settings = userMessageSettingsRepository.findByUserId(receiverId);
if (settings != null) {
    if (!settings.isAllowStrangerMessage() && !isMutualFollow) {
        throw new BusinessException("接收者设置了不允许陌生人私信");
    }
    if (!settings.isAllowNonMutualFollowMessage() && !isMutualFollow) {
        throw new BusinessException("接收者设置了只接收互相关注用户的私信");
    }
}
```

---

### 3. 系统级设置缺失 ⚠️ **中危**

**问题描述**：
- 没有系统级别的私信功能开关
- 无法全局关闭私信功能（维护、升级等场景）
- 无法设置系统级别的私信规则

**风险**：
- 无法在系统维护时临时关闭私信功能
- 无法全局控制私信行为

**影响范围**：
- 系统管理
- 功能控制

**解决方案**：
创建系统配置表或在现有配置中添加私信相关配置：

```sql
CREATE TABLE `system_config` (
  `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '配置ID',
  `config_key` VARCHAR(100) NOT NULL COMMENT '配置键',
  `config_value` VARCHAR(500) NOT NULL COMMENT '配置值',
  `config_desc` VARCHAR(200) DEFAULT NULL COMMENT '配置描述',
  `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_config_key` (`config_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='系统配置表';

-- 插入私信相关配置
INSERT INTO `system_config` (`config_key`, `config_value`, `config_desc`) VALUES
('private_message.enabled', '1', '私信功能开关：0-关闭 1-开启'),
('private_message.allow_stranger', '1', '是否允许陌生人私信：0-不允许 1-允许'),
('private_message.max_message_length', '1000', '私信最大长度'),
('private_message.rate_limit', '10', '私信发送频率限制（条/分钟）');
```

在发送私信时检查系统配置：

```java
// 检查系统私信功能是否开启
SystemConfig config = systemConfigRepository.findByKey("private_message.enabled");
if (config != null && "0".equals(config.getValue())) {
    throw new BusinessException("私信功能暂时关闭");
}
```

---

### 4. 频率限制缺失 ⚠️ **中危**

**问题描述**：
- 没有对私信发送进行频率限制
- 恶意用户可能通过频繁发送私信进行骚扰
- 可能被用于垃圾消息发送

**风险**：
- 用户骚扰
- 系统资源浪费
- 数据库压力

**影响范围**：
- 用户体验
- 系统性能

**解决方案**：
使用 Redis 实现频率限制：

```java
// 在 PrivateMessageDomainService 中添加频率限制检查
private void checkRateLimit(Long senderId) {
    String key = "private_message:rate_limit:" + senderId;
    String count = redisTemplate.opsForValue().get(key);
    
    int currentCount = count == null ? 0 : Integer.parseInt(count);
    int maxCount = getSystemConfigInt("private_message.rate_limit", 10); // 默认10条/分钟
    
    if (currentCount >= maxCount) {
        throw new BusinessException("发送频率过高，请稍后再试");
    }
    
    // 增加计数，设置过期时间1分钟
    redisTemplate.opsForValue().increment(key);
    redisTemplate.expire(key, 60, TimeUnit.SECONDS);
}
```

---

### 5. 消息内容审核缺失 ⚠️ **中危**

**问题描述**：
- 没有对私信内容进行敏感词过滤
- 没有内容审核机制
- 可能传播违规内容

**风险**：
- 传播违规内容
- 法律风险
- 用户体验

**影响范围**：
- 内容安全
- 合规性

**解决方案**：
集成敏感词过滤服务：

```java
// 在发送私信前进行内容审核
private void validateMessageContent(String content) {
    // 1. 检查内容长度
    int maxLength = getSystemConfigInt("private_message.max_message_length", 1000);
    if (content.length() > maxLength) {
        throw new BusinessException("消息内容过长，最多" + maxLength + "字");
    }
    
    // 2. 敏感词过滤
    SensitiveWordFilter filter = sensitiveWordFilterService.getFilter();
    if (filter.containsSensitiveWord(content)) {
        throw new BusinessException("消息包含敏感词汇，请修改后发送");
    }
    
    // 3. 内容审核（可选，可以异步处理）
    // contentReviewService.review(content);
}
```

---

### 6. 接收者主动拒绝能力不足 ⚠️ **低危**

**问题描述**：
- 用户只能通过屏蔽来阻止私信
- 无法设置"只接收互相关注用户的私信"
- 无法完全关闭私信功能

**风险**：
- 用户体验不佳
- 隐私保护不足

**影响范围**：
- 用户体验

**解决方案**：
见"用户隐私设置缺失"解决方案。

---

## 修复优先级

| 隐患 | 优先级 | 影响范围 | 修复难度 |
|------|--------|----------|----------|
| 用户状态检查缺失 | 🔴 高 | 安全性 | 简单 |
| 用户隐私设置缺失 | 🟡 中 | 用户体验 | 中等 |
| 系统级设置缺失 | 🟡 中 | 系统管理 | 简单 |
| 频率限制缺失 | 🟡 中 | 性能/安全 | 中等 |
| 消息内容审核缺失 | 🟡 中 | 内容安全 | 中等 |
| 接收者主动拒绝能力不足 | 🟢 低 | 用户体验 | 中等 |

---

## 建议的修复顺序

1. **第一阶段（必须修复）**：
   - 添加用户状态检查
   - 添加系统级私信功能开关

2. **第二阶段（推荐修复）**：
   - 添加用户隐私设置
   - 添加频率限制

3. **第三阶段（可选修复）**：
   - 添加消息内容审核
   - 优化用户体验

---

## 总结

当前私信系统存在多个权限隐患，主要集中在：
1. **安全性**：用户状态检查缺失
2. **隐私保护**：用户隐私设置缺失
3. **系统控制**：系统级设置缺失
4. **性能安全**：频率限制缺失
5. **内容安全**：消息内容审核缺失

建议按照优先级逐步修复这些隐患，确保系统的安全性和用户体验。

