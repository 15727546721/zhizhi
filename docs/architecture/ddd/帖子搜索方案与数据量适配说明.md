# 帖子搜索方案与数据量适配说明

## 一、当前实现分析

### 1.1 MySQL搜索策略（当前实现）

**实现方式**：
```sql
SELECT * FROM post 
WHERE status = 1 
  AND (title LIKE CONCAT('%', #{keyword}, '%') 
       OR content LIKE CONCAT('%', #{keyword}, '%'))
ORDER BY create_time DESC
LIMIT #{offset}, #{limit}
```

**特点**：
- 使用 `LIKE '%keyword%'` 进行模糊匹配
- 搜索 title 和 content 两个字段
- 全表扫描，无法使用索引（前导通配符导致）
- 按时间倒序排序

**性能分析**：
- 数据量 < 1万：响应时间 < 100ms，可以接受
- 数据量 1-10万：响应时间 100-500ms，开始变慢
- 数据量 10-100万：响应时间 500ms-2s，明显变慢
- 数据量 > 100万：响应时间 > 2s，用户体验差

### 1.2 Elasticsearch搜索策略（当前实现）

**实现方式**：
```java
Page<PostIndex> findByTitleContainingOrderByPublishTimeDesc(String keyword, Pageable pageable)
```

**特点**：
- 使用IK分词器进行中文分词
- 支持相关性排序
- 倒排索引，查询速度快
- 支持高亮显示（可扩展）

**性能分析**：
- 数据量 < 100万：响应时间 < 50ms
- 数据量 100-1000万：响应时间 50-200ms
- 数据量 > 1000万：响应时间 200-500ms
- 性能稳定，不受数据量影响显著

## 二、不同数据量下的推荐方案

### 2.1 小数据量（< 1万条帖子）

**推荐方案：MySQL搜索 + 基础优化**

**配置**：
```yaml
app:
  post:
    query:
      strategy: mysql
```

**优化措施**：
1. **添加索引**（如果还没有）：
   ```sql
   -- 标题索引（用于精确匹配）
   CREATE INDEX idx_post_title ON post(title);
   
   -- 状态+时间索引（用于排序）
   CREATE INDEX idx_post_status_time ON post(status, create_time DESC);
   ```

2. **优化查询**：
   - 仅搜索标题（不搜索content，content字段大）
   - 限制搜索关键词长度（避免过长的LIKE查询）
   - 添加缓存（Redis缓存热门搜索）

3. **性能预期**：
   - 响应时间：< 100ms
   - 并发支持：100-500 QPS

### 2.2 中等数据量（1万 - 10万条帖子）

**推荐方案：MySQL搜索 + 全文索引 / 混合方案**

#### 方案A：MySQL FULLTEXT全文索引

**实现**：
```sql
-- 创建全文索引
ALTER TABLE post ADD FULLTEXT INDEX ft_title_content(title, content);

-- 查询语句
SELECT * FROM post 
WHERE status = 1 
  AND MATCH(title, content) AGAINST(#{keyword} IN NATURAL LANGUAGE MODE)
ORDER BY create_time DESC
LIMIT #{offset}, #{limit}
```

**优点**：
- 无需额外服务
- 支持中文搜索（MySQL 5.7+）
- 性能优于LIKE查询

**缺点**：
- 不支持复杂相关性排序
- 分词能力有限
- 数据量大时性能下降

#### 方案B：Elasticsearch + MySQL混合

**配置**：
```yaml
spring:
  elasticsearch:
    enabled: true
    uris: 127.0.0.1:9200

app:
  post:
    query:
      strategy: elasticsearch  # 优先使用ES
```

**降级策略**：
- ES可用时使用ES搜索
- ES不可用时自动降级到MySQL

**性能预期**：
- 响应时间：50-200ms
- 并发支持：500-1000 QPS

### 2.3 大数据量（10万 - 100万条帖子）

**推荐方案：Elasticsearch（必须）**

**配置**：
```yaml
spring:
  elasticsearch:
    enabled: true
    uris: es-cluster:9200  # 建议使用集群

app:
  post:
    query:
      strategy: elasticsearch
```

**优化措施**：
1. **ES索引优化**：
   ```json
   {
     "settings": {
       "number_of_shards": 3,
       "number_of_replicas": 1,
       "analysis": {
         "analyzer": {
           "ik_max_word": {
             "type": "ik_max_word"
           }
         }
       }
     }
   }
   ```

2. **索引字段优化**：
   - title：使用 ik_max_word 分词器
   - description：使用 ik_max_word 分词器
   - content：如果内容很长，可以考虑不索引或使用不同的analyzer

3. **查询优化**：
   - 使用 bool 查询组合多个条件
   - 使用 filter 而非 query 进行精确匹配
   - 添加缓存层（Redis）

**性能预期**：
- 响应时间：100-300ms
- 并发支持：1000-5000 QPS

### 2.4 超大数据量（> 100万条帖子）

**推荐方案：Elasticsearch集群 + 缓存 + CDN**

**架构设计**：
1. **ES集群**：3个节点以上，分片和副本配置
2. **缓存层**：Redis缓存热门搜索结果
3. **异步索引**：使用消息队列异步更新ES索引
4. **读写分离**：ES集群读写分离

**优化措施**：
1. **索引分片策略**：
   - 按时间分片（如按月分片）
   - 定期归档旧数据

2. **查询优化**：
   - 使用scroll API处理大量结果
   - 限制搜索结果数量
   - 使用filter context提高性能

3. **缓存策略**：
   - 热门关键词缓存（TTL: 1小时）
   - 搜索结果缓存（TTL: 5分钟）
   - 用户个性化推荐缓存

**性能预期**：
- 响应时间：200-500ms
- 并发支持：5000+ QPS

## 三、方案选择决策树

```
数据量判断
├── < 1万
│   └── MySQL + 基础索引 + 缓存
│
├── 1万 - 10万
│   ├── 方案A：MySQL FULLTEXT + 缓存
│   └── 方案B：Elasticsearch（推荐）
│
├── 10万 - 100万
│   └── Elasticsearch（必须）
│
└── > 100万
    └── Elasticsearch集群 + 缓存 + 异步索引
```

## 四、实施建议

### 4.1 当前阶段（建议）

**如果数据量 < 10万**：
1. 使用MySQL搜索策略
2. 添加基础索引优化
3. 添加Redis缓存热门搜索
4. 为将来迁移到ES做准备

**如果数据量 > 10万**：
1. 立即启用Elasticsearch
2. 配置ES集群（至少2个节点）
3. 实现数据同步机制
4. 添加缓存层

### 4.2 优化建议

#### MySQL优化（小数据量）
```sql
-- 1. 添加索引
CREATE INDEX idx_post_title ON post(title(100));  -- 前缀索引
CREATE INDEX idx_post_status_time ON post(status, create_time DESC);

-- 2. 如果MySQL版本 >= 5.7，使用全文索引
ALTER TABLE post ADD FULLTEXT INDEX ft_title(title, description);

-- 3. 优化查询（仅搜索标题，不搜索content）
SELECT * FROM post 
WHERE status = 1 
  AND title LIKE CONCAT('%', #{keyword}, '%')
ORDER BY create_time DESC
LIMIT #{offset}, #{limit};
```

#### Elasticsearch优化（大数据量）
```java
// 1. 使用更精确的查询
BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()
    .should(QueryBuilders.matchQuery("title", keyword).boost(2.0f))
    .should(QueryBuilders.matchQuery("description", keyword).boost(1.0f))
    .minimumShouldMatch(1);

// 2. 添加filter（不计算评分，性能更好）
boolQuery.filter(QueryBuilders.termQuery("status", 1));

// 3. 限制搜索结果
SearchRequest request = new SearchRequest("posts");
request.source().size(20).from(0);
```

### 4.3 缓存策略

**Redis缓存设计**：
```java
// 缓存key设计
String cacheKey = "post:search:" + keyword + ":" + page + ":" + size;

// 缓存策略
// 1. 热门搜索：TTL = 1小时
// 2. 普通搜索：TTL = 5分钟
// 3. 冷门搜索：不缓存
```

## 五、性能监控指标

### 5.1 关键指标

1. **响应时间**：
   - P50（中位数）：< 100ms
   - P95：< 300ms
   - P99：< 500ms

2. **QPS（每秒查询数）**：
   - 小数据量：100-500 QPS
   - 中等数据量：500-1000 QPS
   - 大数据量：1000-5000 QPS

3. **错误率**：
   - 目标：< 0.1%
   - 降级成功率：> 99%

### 5.2 监控方案

```java
// 添加监控指标
@Timed(name = "post.search", description = "Post search performance")
public Page<PostEntity> search(String keyword, Pageable pageable) {
    // 记录搜索关键词
    metricsService.recordSearch(keyword);
    
    // 记录响应时间
    long startTime = System.currentTimeMillis();
    try {
        Page<PostEntity> result = strategy.search(keyword, pageable);
        metricsService.recordSearchLatency(System.currentTimeMillis() - startTime);
        return result;
    } catch (Exception e) {
        metricsService.recordSearchError(keyword, e);
        throw e;
    }
}
```

## 六、迁移方案

### 6.1 从MySQL迁移到Elasticsearch

**步骤**：
1. **准备阶段**：
   - 安装和配置Elasticsearch
   - 创建索引和映射
   - 配置IK分词器

2. **数据同步**：
   - 全量同步：一次性导入所有历史数据
   - 增量同步：使用消息队列实时同步新数据

3. **灰度切换**：
   - 10%流量使用ES
   - 逐步增加到100%
   - 监控性能和错误率

4. **回滚方案**：
   - 保留MySQL搜索代码
   - 支持快速切换回MySQL

### 6.2 数据同步方案

**方案A：同步更新（实时）**
```java
@EventListener
public void onPostCreated(PostCreatedEvent event) {
    postElasticService.indexPost(event.getPost());
}
```

**方案B：异步更新（最终一致性）**
```java
@EventListener
public void onPostCreated(PostCreatedEvent event) {
    messageQueue.send("post.index", event.getPost());
}
```

## 七、总结

### 7.1 推荐方案

| 数据量 | 推荐方案 | 响应时间 | 成本 |
|--------|---------|---------|------|
| < 1万 | MySQL + 索引 | < 100ms | 低 |
| 1-10万 | MySQL FULLTEXT 或 ES | 50-200ms | 中 |
| 10-100万 | Elasticsearch | 100-300ms | 中高 |
| > 100万 | ES集群 + 缓存 | 200-500ms | 高 |

### 7.2 最佳实践

1. **渐进式优化**：根据实际数据量选择方案，不要过度设计
2. **监控优先**：先添加监控，再优化性能
3. **降级策略**：始终保留MySQL作为兜底方案
4. **缓存策略**：合理使用缓存，减少数据库压力
5. **索引优化**：定期检查和优化索引

### 7.3 下一步行动

1. **评估当前数据量**：统计当前帖子数量
2. **性能测试**：测试当前搜索性能
3. **选择方案**：根据数据量选择合适方案
4. **实施优化**：按步骤实施优化措施
5. **监控和调优**：持续监控和优化性能

