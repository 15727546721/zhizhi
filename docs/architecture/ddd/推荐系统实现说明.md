# 推荐系统实现说明

## ⚠️ 重要提示：业务合理性分析

**对于小系统（用户量 < 1万），基于用户行为的推荐功能可能不是必需的。**

详细分析请参考：[推荐功能业务合理性分析.md](./推荐功能业务合理性分析.md)

### 快速结论

- ❌ **小系统不建议**做复杂的用户行为推荐（数据稀疏，效果差）
- ✅ **推荐使用简化版**：热门 + 精选 + 关注
- ✅ **现有功能已足够**：最新、热门、关注、搜索、标签筛选

### 推荐方案选择

| 系统规模 | 推荐方案 | 实现类 |
|---------|---------|--------|
| 小系统（< 1万用户） | 简化推荐（热门+精选） | `SimpleRecommendServiceImpl` |
| 中等系统（1-10万用户） | 简化推荐 + 基于关注 | `SimpleRecommendServiceImpl` |
| 大系统（> 10万用户） | 完整用户行为推荐 | `RecommendServiceImpl` |

## 概述

本文档说明了知之社区系统基于用户行为的内容推荐功能的实现。

**注意**：当前实现了两个版本：
1. **完整版**（`RecommendServiceImpl`）：适合大系统
2. **简化版**（`SimpleRecommendServiceImpl`）：适合小系统（推荐使用）

## 推荐策略

系统采用混合推荐策略，结合多种推荐算法：

1. **基于用户行为的协同过滤推荐（40%权重）**
   - 找到与当前用户行为相似的用户（基于点赞、收藏）
   - 推荐相似用户喜欢的帖子

2. **基于内容的推荐（30%权重）**
   - 根据用户喜欢的标签和话题推荐相似内容
   - 基于标签相似度推荐帖子

3. **基于关注用户的推荐（20%权重）**
   - 推荐用户关注的人发布的帖子

4. **基于热度的推荐（10%权重，兜底策略）**
   - 推荐热门帖子

## 核心类说明

### 1. IRecommendService（推荐服务接口）

位置：`cn.xu.domain.recommend.service.IRecommendService`

主要方法：
- `getRecommendedPosts()`: 获取推荐帖子列表（混合策略）
- `getCollaborativeFilteringRecommendations()`: 协同过滤推荐
- `getContentBasedRecommendations()`: 基于内容的推荐
- `getFollowingBasedRecommendations()`: 基于关注的推荐
- `getHotRecommendations()`: 热门推荐

### 2. RecommendServiceImpl（推荐服务实现）

位置：`cn.xu.domain.recommend.service.impl.RecommendServiceImpl`

实现了所有推荐策略的核心逻辑。

## 需要实现的仓储方法

以下方法需要在对应的仓储实现类中实现：

### 1. ILikeAggregateRepository（点赞聚合根仓储）

需要在 `LikeAggregateRepositoryImpl` 中实现：

```java
/**
 * 获取用户点赞的目标ID列表
 */
List<Long> findLikedTargetIdsByUser(Long userId, LikeType type);

/**
 * 获取点赞某个目标的用户ID列表
 */
List<Long> findUserIdsByTarget(Long targetId, LikeType type);
```

**SQL实现建议：**
```sql
-- 获取用户点赞的帖子ID列表
SELECT target_id FROM `like` 
WHERE user_id = #{userId} AND type = #{type} AND status = 1;

-- 获取点赞某个帖子的用户ID列表
SELECT user_id FROM `like` 
WHERE target_id = #{targetId} AND type = #{type} AND status = 1;
```

### 2. IFavoriteRepository（收藏仓储）

需要在收藏仓储实现类中实现：

```java
/**
 * 获取收藏某个目标的用户ID列表
 */
List<Long> findUserIdsByTarget(Long targetId, String targetType);
```

**SQL实现建议：**
```sql
SELECT user_id FROM `favorite` 
WHERE target_id = #{targetId} AND target_type = #{targetType} AND status = 1;
```

### 3. ITagRepository（标签仓储）

需要在 `TagRepository` 中实现：

```java
/**
 * 根据帖子ID获取标签ID列表
 */
List<Long> findTagIdsByPostId(Long postId);
```

**SQL实现建议：**
```sql
SELECT tag_id FROM `post_tag` WHERE post_id = #{postId};
```

### 4. ITopicRepository（话题仓储）

需要在话题仓储实现类中实现：

```java
/**
 * 根据帖子ID获取话题ID列表
 */
List<Long> findTopicIdsByPostId(Long postId);

/**
 * 根据话题ID获取帖子列表
 */
List<PostEntity> findPostsByTopicId(Long topicId, int offset, int limit);
```

**SQL实现建议：**
```sql
-- 获取帖子的话题ID列表
SELECT topic_id FROM `post_topic` WHERE post_id = #{postId};

-- 根据话题ID获取帖子列表
SELECT p.* FROM `post` p
INNER JOIN `post_topic` pt ON p.id = pt.post_id
WHERE pt.topic_id = #{topicId} AND p.status = 1
ORDER BY p.create_time DESC
LIMIT #{offset}, #{limit};
```

## 使用方式

### 在PostService中使用

推荐服务已经集成到 `PostService.findRecommendedPosts()` 方法中：

```java
@Override
public List<PostEntity> findRecommendedPosts(Long userId, Integer pageNo, Integer pageSize) {
    // 使用推荐服务获取推荐帖子
    if (recommendService != null) {
        return recommendService.getRecommendedPosts(userId, pageNo, pageSize);
    }
    
    // 降级处理：如果没有推荐服务，返回热门帖子
    int offset = Math.max(0, (pageNo - 1) * pageSize);
    return postRepository.findHotPosts(offset, pageSize);
}
```

### API调用

推荐功能已经集成到现有的API中：

- `GET /api/home/recommended` - 获取推荐帖子列表

## 性能优化建议

1. **缓存策略**
   - 推荐结果可以缓存1小时
   - 用户行为数据可以缓存30分钟

2. **异步计算**
   - 对于大数据量，可以考虑异步计算推荐结果
   - 使用定时任务预计算热门推荐

3. **分页优化**
   - 推荐结果支持分页，避免一次性加载过多数据

## 后续优化方向

1. **机器学习推荐**
   - 引入机器学习模型（如协同过滤、深度学习）
   - 使用用户画像进行个性化推荐

2. **实时推荐**
   - 基于用户实时行为调整推荐结果
   - 使用流式计算处理用户行为数据

3. **A/B测试**
   - 支持多种推荐策略的A/B测试
   - 根据效果调整推荐权重

4. **推荐解释**
   - 向用户展示推荐理由（如"因为你关注了XXX"）

## 用户行为画像数据存储

### 当前实现（实时查询）

目前用户行为画像数据是**分散存储**在各个业务表中，每次推荐时**实时查询**：

1. **点赞数据**：存储在 `like` 表
2. **收藏数据**：存储在 `favorite` 表
3. **关注数据**：存储在 `follow` 表
4. **标签关联**：存储在 `post_tag` 表
5. **话题关联**：存储在 `post_topic` 表

**优点**：
- 数据实时准确
- 不需要额外的存储空间
- 实现简单

**缺点**：
- 每次推荐都需要查询多张表，性能开销大
- 没有预计算的用户偏好，推荐效率低
- 无法快速获取用户画像

### 优化方案选择（根据系统规模）

> ⚠️ **重要提示**：对于小系统（用户量 < 1万），创建多张画像表可能**过度设计**。建议根据系统规模选择合适的方案。

#### 方案一：Redis缓存优化（推荐⭐ - 适合小系统）

**无需创建新表**，只需使用Redis缓存用户偏好数据。

**实现**：
- 定时任务每天计算一次用户偏好（标签、话题）
- 缓存到Redis（1-24小时过期）
- 推荐时优先从缓存读取

**优点**：
- ✅ 无需创建新表，改动小
- ✅ 性能提升明显
- ✅ 维护成本低
- ✅ 适合小系统

**详细方案**：参考 [小系统推荐优化方案.md](./小系统推荐优化方案.md)

#### 方案二：单表简化版（适合中等系统）

只创建**1张核心表**：`user_profile`，存储最关键的画像数据。

**表结构**：
- 偏好标签ID列表（JSON）
- 偏好话题ID列表（JSON）
- 最后更新时间

**优点**：
- ✅ 只有1张表，维护简单
- ✅ 存储核心偏好数据
- ✅ 可以逐步扩展

#### 方案三：完整画像表（适合大系统）

创建完整的用户画像表体系（5张表），适合大规模系统。

**详细表结构**：参考 `user_profile_tables.sql`

**适用场景**：
- 用户量 > 10万
- 日活 > 1万
- 推荐请求频繁
- 需要复杂推荐算法

### 渐进式实施建议

1. **当前阶段（小系统）**：使用**方案一**（Redis缓存）
2. **用户量增长（5000-10000）**：考虑**方案二**（单表简化版）
3. **大规模系统（> 10万）**：使用**方案三**（完整画像表）

详细说明请参考：[小系统推荐优化方案.md](./小系统推荐优化方案.md)

## 注意事项

1. 新用户（没有行为数据）会直接返回热门推荐
2. 推荐结果会自动去重，避免重复推荐
3. 推荐算法会排除用户已经交互过的帖子
4. 如果某个推荐策略没有结果，会自动使用其他策略补充
5. **用户画像数据**目前是实时查询，建议后续实现画像表来提升性能

