# 私信系统

> 基于 SpringBoot + SpringEvent 的轻量级私信系统

## 一、系统概述

### 核心价值
在开放社区环境下，平衡用户沟通需求与防骚扰需求：
- **互相关注用户**：无限制自由聊天
- **陌生用户**：可发送1条消息建立联系，需等待回复才能继续
- **被屏蔽用户**：完全禁止发送

### 系统特色
| 特性 | 说明 |
|------|------|
| **轻量级** | 单体项目，无MQ依赖 |
| **强防骚扰** | 4重核心防护 |
| **事件驱动** | SpringEvent解耦业务 |
| **用户视角** | 会话表每用户独立记录，查询简单 |

---

## 二、数据库设计

### 核心表（5张）

| 表名 | 说明 |
|------|------|
| `user_conversation` | 用户会话（用户视角设计） |
| `private_message` | 私信消息 |
| `greeting_record` | 打招呼记录（防骚扰） |
| `user_block` | 用户屏蔽关系 |
| `notification` | 统一通知表 |

### 用户会话表设计理念
```
每个用户独立一条会话记录：
- A和B聊天 → user_conversation 有2条记录
- 记录1: owner_id=A, other_user_id=B （A的视角）
- 记录2: owner_id=B, other_user_id=A （B的视角）

好处：
- 查询简单：WHERE owner_id = 当前用户ID
- 未读数独立：各自维护各自的未读数
- 删除独立：A删除会话不影响B
```

---

## 三、权限矩阵

| 用户关系 | 发送规则 | 消息可见性 |
|---------|----------|-----------|
| **互相关注** | 无限制发送 | 双方可见 |
| **非互关首次** | 允许发送1条 | 对方可见 |
| **非互关后续** | 等待回复后才能继续 | 发送方看到提示 |
| **对方回复后** | 建立对话关系，自由聊天 | 双方可见 |
| **被屏蔽** | 完全禁止发送 | - |

---

## 四、防骚扰机制

### 4重核心防护

| # | 策略 | 说明 | 实现 |
|---|------|------|------|
| ① | 打招呼限制 | 单向关注仅能发1条 | `greeting_record` 表 |
| ② | 关注限制 | 无关注 → 禁止私信 | `follow` 表判断 |
| ③ | 拉黑机制 | 双向不可发 | `user_block` 表 |
| ④ | 文本长度 | 最多500字 | 参数校验 |

### 实际场景

**场景1：正常社交**
```
B想向A请教问题，发送消息
  ✅ 消息送达，A收到通知
A回复
  ✅ 建立对话关系，后续可自由聊天
```

**场景2：骚扰拦截**
```
C发送营销消息给D
  ✅ 首次消息送达（给一次机会）
D不感兴趣，未回复
C继续发送广告
  ❌ 消息被拦截，D看不到
```

---

## 五、核心流程

### 发送消息流程

```
用户A → 发私信 → sendMessage()
    │
    ├── 1. 参数校验（含500字长度限制）
    ├── 2. 权限检查 (canSendDM)
    │       ├── 拉黑判断
    │       ├── 互关判断 → 直接通过
    │       ├── 对方是否回复过 → 升级为自由会话
    │       └── 打招呼记录检查 → 允许/拒绝
    ├── 3. 保存消息 (MessageRepository)
    ├── 4. 更新会话 (ConversationRepository)
    │       ├── 更新发送方会话
    │       └── 创建/更新接收方会话
    ├── 5. 记录打招呼 (GreetingRecordRepository)
    └── 6. 事务提交后发布事件
              │
              ▼
    DMEventListener.onDMSent()
        ├── 创建通知
        └── WebSocket推送（可选）
```

---

## 六、API接口

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/messages/can-send/{userId}` | 检查私信权限 |
| POST | `/api/messages` | 发送私信 |
| POST | `/api/messages/image` | 发送图片 |
| GET | `/api/messages/conversations` | 获取会话列表 |
| POST | `/api/messages/conversations/{userId}` | 获取或创建会话 |
| GET | `/api/messages/conversations/{userId}/messages` | 获取消息列表 |
| POST | `/api/messages/conversations/{userId}/read` | 标记已读 |
| GET | `/api/messages/unread/total` | 获取总未读数 |

### 权限检查返回示例
```json
{
  "code": 20000,
  "data": {
    "canSend": true,
    "isGreeting": true,
    "reason": null
  }
}
```

---

## 七、核心代码结构

```
service/message/
├── PrivateMessageService.java      # 核心服务（权限+发送+会话）
└── UserBlockService.java           # 屏蔽服务

event/message/
├── DMSentEvent.java                # 私信发送事件
├── DMEventPublisher.java           # 事件发布器
└── DMEventListener.java            # 事件监听器

repository/
├── IPrivateMessageRepository.java  # 消息仓储接口
├── IUserConversationRepository.java# 会话仓储接口
├── IGreetingRecordRepository.java  # 打招呼记录仓储
└── impl/                           # 实现类

model/entity/
├── PrivateMessage.java             # 消息实体
├── UserConversation.java           # 会话实体
└── GreetingRecord.java             # 打招呼记录实体
```

---

## 八、消息状态

| 状态 | 值 | 说明 |
|------|---|------|
| STATUS_DELIVERED | 1 | 已送达，对方可见 |
| STATUS_PENDING | 2 | 待回复，对方不可见（防骚扰） |
| STATUS_BLOCKED | 3 | 被屏蔽，对方不可见 |
| STATUS_WITHDRAWN | 4 | 已撤回 |

---

## 九、通知类型

| 类型 | 值 | 说明 |
|------|---|------|
| TYPE_SYSTEM | 0 | 系统通知 |
| TYPE_LIKE | 1 | 点赞 |
| TYPE_FAVORITE | 2 | 收藏 |
| TYPE_COMMENT | 3 | 评论 |
| TYPE_REPLY | 4 | 回复 |
| TYPE_FOLLOW | 5 | 关注 |
| TYPE_MENTION | 6 | @提及 |
| TYPE_PRIVATE_MESSAGE | 7 | 私信通知 |

---

## 十、定时任务

### 消息清理任务
```java
@Scheduled(cron = "0 0 3 * * ?")  // 每天凌晨3点
public void cleanDeletedMessages() {
    // 物理删除双方都已删除的消息
    messageMapper.deleteBothDeletedMessages();
}
```

**清理逻辑**：
- A删除会话 → `sender_deleted=1`（B还能看）
- B删除会话 → `receiver_deleted=1`（双方都看不到）
- 定时任务 → 物理删除（节省存储）

---

*文档更新时间: 2025-12-06*
