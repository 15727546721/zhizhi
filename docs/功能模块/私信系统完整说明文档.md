# 私信系统业务说明文档

## 目录
- [1. 核心业务价值](#1-核心业务价值)
- [2. 防骚扰机制](#2-防骚扰机制)
- [3. 用户使用场景](#3-用户使用场景)
- [4. 数据库设计](#4-数据库设计)
- [5. API接口](#5-api接口)
- [6. 技术实现](#6-技术实现)
- [7. 部署运维](#7-部署运维)

---

## 1. 核心业务价值

### 1.1 解决的核心问题
**🎯 在开放社区环境下，如何平衡用户沟通需求与防骚扰需求？**

- **用户痛点**：完全开放 → 垃圾消息泛滥；完全封闭 → 无法建立新联系
- **系统方案**：智能防骚扰机制 → 允许合理接触，防止无限骚扰
- **核心价值**：让用户在安全的环境下进行有意义的私信交流

### 1.2 系统特色

#### 🛡️ 智能防骚扰
- **互相关注用户**：无限制自由聊天
- **陌生用户**：可发送1条消息建立联系，需等待回复才能继续
- **骚扰用户**：自动识别并隔离，保护接收方

#### 🔒 隐私保护
- **静默拒绝**：被屏蔽时不告知发送方，保护隐私
- **状态控制**：精确控制消息可见性，防止信息泄露
- **权限分级**：用户可自主设置私信接收规则

#### 📱 用户体验
- **无感防骚扰**：正常用户感知不到防骚扰机制存在
- **即时反馈**：发送状态实时提示，用户体验清晰
- **数据同步**：多端消息状态实时同步

### 1.3 适用场景
- **社交社区**：知识分享、兴趣交流社区
- **商务平台**：B2B、B2C平台的商务沟通
- **教育平台**：师生、同学间的学习交流
- **企业内部**：跨部门协作沟通工具
---

## 2. 防骚扰机制

### 2.1 核心原理
**🎯 基于信任关系的渐进式沟通模式**

系统将用户关系分为三个等级：
1. **互相关注** → 完全信任 → 自由聊天
2. **单向关注/陌生人** → 待验证 → 限制性沟通  
3. **被屏蔽** → 零信任 → 完全拒绝

### 2.2 防骚扰规则矩阵

#### 规则矩阵
| 用户关系 | 发送规则 | 消息可见性 | 备注 |
|---------|----------|-----------|------|
| **互相关注** | 无限制发送 | 双方可见 | 自由聊天模式 |
| **非互关首次** | 允许发送1条 | 对方可见 | 建立联系机会 |
| **非互关后续** | 等待回复后才能继续 | 对方不可见 | 防骚扰机制 |
| **对方回复后** | 建立对话关系，自由聊天 | 双方可见 | 信任关系建立 |
| **被屏蔽** | 完全禁止发送 | 对方不可见 | 最高优先级 |

### 2.3 实际应用示例

#### 场景1：正常社交
```
👤 用户A（技术博主）
👤 用户B（技术新人）

1. B想向A请教技术问题，发送消息："您好，想请教一个React问题"
   ✅ 消息送达，A收到通知
   
2. A查看消息，觉得合理，回复："可以，你说"
   ✅ 建立对话关系，后续可自由聊天
   
3. B继续提问，A耐心解答
   ✅ 正常技术交流，达成互助目的
```

#### 场景2：骚扰拦截
```
👤 用户C（营销号）  
👤 用户D（普通用户）

1. C发送营销消息："了解一下我们的产品"
   ✅ 消息送达，D收到（给一次机会）
   
2. D不感兴趣，未回复
   
3. C继续发送："真的很优惠"
   ❌ 消息被拦截，D看不到（防骚扰生效）
   
4. C再次发送广告
   ❌ 继续拦截，保护D不受打扰
```

---

## 3. 用户使用场景

### 3.1 发送私信
**用户操作流程**：
1. 用户在个人主页或帖子下点击"私信"按钮
2. 输入消息内容（文本/图片），点击发送
3. 系统显示发送状态：
   - ✅ "消息已送达" - 对方能看到
   - ⏳ "消息已保存，等待对方回复" - 触发防骚扰
   - ❌ "发送失败" - 被屏蔽或其他限制

### 3.2 接收私信
**用户体验**：
1. 收到私信通知（站内信/推送/邮件）
2. 进入私信页面查看消息
3. 可选择：
   - 回复消息 → 建立对话关系
   - 屏蔽对方 → 拒绝后续消息
   - 忽略消息 → 触发对方防骚扰机制

### 3.3 管理对话
**功能特性**：
- **对话列表**：按最后消息时间排序，显示未读数
- **消息搜索**：快速找到历史对话内容
- **批量操作**：一键标记已读、删除对话
- **屏蔽管理**：查看和管理屏蔽用户列表

---

## 4. 数据库设计

### 3.1 表结构总览

| 表名 | 用途 | 重要性 | 记录数量级 |
|------|------|--------|-----------|
| `message` | 存储所有消息 | 🔴 核心 | 千万级 |
| `conversation` | 对话关系和状态 | 🔴 核心 | 十万级 |
| `user_block` | 用户屏蔽关系 | 🟡 重要 | 万级 |
| `user_message_settings` | 用户私信设置 | 🟢 可选 | 十万级 |
| `private_message_config` | 系统配置 | 🟢 可选 | 10条以内 |

### 3.2 核心表详解

#### 3.2.1 conversation表（核心创新）
```sql
CREATE TABLE `conversation` (
  `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
  `user_id_1` BIGINT UNSIGNED NOT NULL COMMENT '较小的用户ID',
  `user_id_2` BIGINT UNSIGNED NOT NULL COMMENT '较大的用户ID', 
  `initiator_id` BIGINT UNSIGNED NOT NULL COMMENT '发起者ID（防骚扰核心）',
  `status` TINYINT NOT NULL DEFAULT 0 COMMENT '0-待回复 1-已建立对话',
  `last_message_time` DATETIME NOT NULL COMMENT '最后消息时间',
  -- ...其他字段
);
```

**创新点**：
- `user_id_1 < user_id_2`：确保用户对的唯一性
- `initiator_id`：记录谁先发起对话，用于防骚扰判断
- `status`：对话状态，替代原来的first_message表

#### 3.2.2 message表状态设计
```sql
-- status字段含义（私信专用）
-- 1 (STATUS_DELIVERED): 已送达，接收方可见
-- 2 (STATUS_PENDING): 待送达，接收方不可见（防骚扰）
-- 3 (STATUS_BLOCKED): 已屏蔽，接收方不可见
```

### 3.3 索引策略

#### 高频查询索引
```sql
-- conversation表
UNIQUE KEY `uk_user_pair` (`user_id_1`, `user_id_2`), -- 防重复
KEY `idx_last_message_time` (`last_message_time`),     -- 对话排序
KEY `idx_initiator_status` (`initiator_id`, `status`), -- 防骚扰查询

-- message表（复用现有）
KEY `idx_sender_receiver_status` (`sender_id`, `receiver_id`, `status`),
KEY `idx_receiver_unread` (`receiver_id`, `is_read`),
```

---

## 4. 业务逻辑详解

### 4.1 发送消息核心流程

```java
public SendResult sendMessage(Long senderId, Long receiverId, String content) {
    // 1. 屏蔽检查（最高优先级）
    if (isBlocked(receiverId, senderId)) {
        throw new BusinessException("发送失败"); // 静默拒绝
    }
    
    // 2. 互相关注检查
    if (isMutualFollow(senderId, receiverId)) {
        return sendMutualFollowMessage(); // 直接发送
    }
    
    // 3. 非互关防骚扰逻辑
    return sendNonMutualFollowMessage();
}
```

### 4.2 防骚扰详细逻辑

#### 场景A：互相关注用户
```
A ←→ B (互相关注)
├── A发消息给B：直接送达 ✅
├── B发消息给A：直接送达 ✅
└── 无任何限制，自由聊天
```

#### 场景B：非互相关注，首次发送
```
A → B (单方面关注或陌生人)
├── A首次发消息给B
├── 创建conversation(initiator_id=A, status=0)
├── 消息status=1，B可以看到 ✅
└── A可以在对话列表找到B
```

#### 场景C：发起者继续发送（防骚扰）
```
A继续发消息给B（B尚未回复）
├── 检查conversation(initiator_id=A, status=0)
├── 发现A是发起者且B未回复
├── 消息status=2，B看不到 ❌
└── A看到提示："对方尚未回复，消息已保存但对方暂时看不到"
```

#### 场景D：接收者回复（建立对话）
```
B回复A的消息
├── 检查conversation(initiator_id=A, status=0)
├── 发现B不是发起者，这是回复
├── 更新conversation.status=1（建立对话关系）
├── 消息status=1，A可以看到 ✅
└── 之后A和B可以自由聊天
```

### 4.3 查询逻辑优化

#### 消息列表查询（关键算法）
```sql
-- 当前用户看到的消息（防骚扰过滤）
SELECT * FROM message 
WHERE type = 2 
AND (
  -- 发送者看到：自己发送的所有消息（包括status=2）
  (sender_id = #{currentUserId} AND receiver_id = #{otherUserId})
  OR 
  -- 接收者看到：只能看到status=1的消息
  (sender_id = #{otherUserId} AND receiver_id = #{currentUserId} AND status = 1)
)
ORDER BY create_time ASC;
```

#### 对话列表查询
```sql
-- 获取用户的所有对话，按最后消息时间排序
SELECT * FROM conversation 
WHERE user_id_1 = #{userId} OR user_id_2 = #{userId}
ORDER BY last_message_time DESC;
```

---

## 5. API接口说明

### 5.1 接口概览

| 接口路径 | 方法 | 功能 | 权限 |
|---------|------|------|------|
| `POST /api/private-messages-v2` | POST | 发送私信 | 登录用户 |
| `GET /api/private-messages-v2/conversations/{userId}` | GET | 获取消息列表 | 登录用户 |
| `GET /api/private-messages-v2/conversations` | GET | 获取对话列表 | 登录用户 |
| `POST /api/private-messages-v2/conversations/{userId}/read` | POST | 标记已读 | 登录用户 |
| `GET /api/private-messages-v2/conversations/{userId}/unread-count` | GET | 获取未读数 | 登录用户 |
| `POST /api/private-messages-v2/users/{userId}/block` | POST | 屏蔽用户 | 登录用户 |
| `DELETE /api/private-messages-v2/users/{userId}/block` | DELETE | 取消屏蔽 | 登录用户 |

### 5.2 核心接口详解

#### 5.2.1 发送私信
```http
POST /api/private-messages-v2
Content-Type: application/json

{
  "receiverId": 123,
  "content": "你好，请问..."
}
```

**响应示例**：
```json
{
  "code": 20000,
  "data": {
    "messageId": 456789,
    "status": 1,
    "message": "消息已送达"
  },
  "info": "消息已送达"
}
```

**状态说明**：
- `status: 1`：消息已送达，对方可见
- `status: 2`：消息已保存，但对方暂时看不到（防骚扰）
- 失败时抛出异常（如被屏蔽）

#### 5.2.2 获取消息列表
```http
GET /api/private-messages-v2/conversations/123?pageNo=1&pageSize=20
```

**响应示例**：
```json
{
  "code": 20000,
  "data": [
    {
      "messageId": 456789,
      "senderId": 100,
      "senderName": "用户A",
      "senderAvatar": "avatar_url",
      "receiverId": 123,
      "content": "你好，请问...",
      "status": 1,
      "isRead": false,
      "createTime": "2025-11-26T10:30:00"
    }
  ]
}
```

---

## 6. 代码架构

### 6.1 架构设计图

```
┌─────────────────────────────────────────────────────────┐
│                    Controller层                          │
│         EnhancedPrivateMessageController               │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│                    Service层（简化）                      │
│  ┌─────────────────────┐  ┌─────────────────────┐      │
│  │EnhancedPrivateMessage│  │ SimpleUserBlock     │      │
│  │Service（核心业务）    │  │ Service（屏蔽管理）  │      │
│  │ ~250行代码           │  │ ~80行代码           │      │
│  └─────────────────────┘  └─────────────────────┘      │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│                Repository/Mapper层                       │
│   SimpleConversationRepository + PrivateMessageRepo     │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│              数据库层（3张核心表）                        │
│     conversation + message + user_block                │
└─────────────────────────────────────────────────────────┘
```

### 6.2 核心类说明

#### 6.2.1 EnhancedPrivateMessageService
```java
@Service("enhancedPrivateMessageService")
public class EnhancedPrivateMessageService {
    // 核心方法
    public SendResult sendMessage(Long senderId, Long receiverId, String content);
    public List<Message> getMessagesBetweenUsers(Long userId1, Long userId2, int pageNo, int pageSize);
    public List<Conversation> getConversationList(Long userId, int pageNo, int pageSize);
    public void markAsRead(Long receiverId, Long senderId);
    public long getUnreadCount(Long receiverId, Long senderId);
}
```

#### 6.2.2 Conversation PO（增强版）
```java
public class Conversation {
    // 数据库字段
    private Long id;
    private Long userId1, userId2;
    private Long initiatorId;  // 新增：发起者ID
    private Integer status;    // 新增：对话状态
    
    // 业务方法
    public boolean isPending();           // 是否待回复状态
    public boolean isEstablished();       // 是否已建立对话
    public boolean isInitiator(Long userId); // 是否发起者
    public void establish();              // 建立对话关系
}
```

### 6.3 设计模式应用

| 模式 | 应用场景 | 好处 |
|------|----------|------|
| **充血模型** | Conversation PO包含业务逻辑 | 领域逻辑内聚 |
| **策略模式** | 互关/非互关不同发送策略 | 逻辑清晰分离 |
| **模板方法** | 消息发送流程统一模板 | 代码复用 |
| **工厂方法** | Conversation创建方法 | 对象创建集中 |

---

## 7. 部署指南

### 7.1 数据库部署

#### 步骤1：执行SQL脚本
```bash
# 进入MySQL
mysql -u root -p

# 选择数据库
USE your_database_name;

# 执行私信系统SQL
source /path/to/private_message_system_complete.sql;
```

#### 步骤2：验证表结构
```sql
-- 检查表是否创建成功
SHOW TABLES LIKE '%conversation%';
SHOW TABLES LIKE '%user_block%';

-- 检查索引是否创建
SHOW INDEX FROM conversation;
```

### 7.2 应用部署

#### 步骤1：编译验证
```bash
cd zhizhi-backend
mvn clean compile
# 确保编译成功
```

#### 步骤2：配置检查
```yaml
# application.yml 确保数据源配置正确
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/your_db?useUnicode=true&characterEncoding=utf8mb4
    username: your_username
    password: your_password
```

#### 步骤3：启动应用
```bash
mvn spring-boot:run
```

#### 步骤4：接口测试
```bash
# 测试发送私信接口
curl -X POST http://localhost:8091/api/private-messages-v2 \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your_token" \
  -d '{"receiverId": 123, "content": "测试消息"}'
```

### 7.3 迁移方案

如果从旧版本升级：

#### 数据迁移
```sql
-- 1. 备份现有数据
CREATE TABLE conversation_backup AS SELECT * FROM conversation;
CREATE TABLE message_backup AS SELECT * FROM message WHERE type = 2;

-- 2. 执行新表结构
-- （执行 private_message_system_complete.sql）

-- 3. 数据迁移脚本
-- 将现有对话标记为已建立状态
UPDATE conversation SET 
  initiator_id = created_by,
  status = 1 
WHERE status = 0 OR status IS NULL;
```

#### 平滑升级
```java
// 保持两套接口并行
// 旧接口：/api/private-messages
// 新接口：/api/private-messages-v2
// 前端逐步迁移到新接口
```

---

## 8. 性能与扩展

### 8.1 性能优化

#### 数据库层优化
```sql
-- 1. 核心查询索引已优化
-- 2. 分区建议（大数据量时）
ALTER TABLE message PARTITION BY RANGE (YEAR(create_time)) (
  PARTITION p2024 VALUES LESS THAN (2025),
  PARTITION p2025 VALUES LESS THAN (2026),
  PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- 3. 定期清理建议
-- 清理6个月前的待回复对话
DELETE FROM conversation 
WHERE status = 0 
AND update_time < DATE_SUB(NOW(), INTERVAL 6 MONTH);
```

#### 缓存策略
```java
// Redis缓存热点数据
@Cacheable(value = "conversation_list", key = "#userId")
public List<Conversation> getConversationList(Long userId);

@Cacheable(value = "unread_count", key = "#receiverId + ':' + #senderId")  
public long getUnreadCount(Long receiverId, Long senderId);
```

### 8.2 扩展功能

#### 已预留扩展点
```sql
-- 1. 消息撤回
ALTER TABLE message ADD COLUMN is_recalled TINYINT DEFAULT 0;

-- 2. 消息置顶对话
ALTER TABLE conversation ADD COLUMN is_pinned TINYINT DEFAULT 0;

-- 3. 消息加密
ALTER TABLE message ADD COLUMN encryption_type VARCHAR(50);

-- 4. 群聊支持
CREATE TABLE group_conversation (
  id BIGINT PRIMARY KEY,
  group_id BIGINT NOT NULL,
  -- 群聊扩展字段
);
```

#### 高级功能
- **消息同步**：支持多端消息同步
- **消息搜索**：集成ElasticSearch全文搜索
- **智能过滤**：AI识别垃圾消息
- **消息翻译**：多语言实时翻译
- **阅后即焚**：敏感消息自动销毁

### 8.3 监控指标

#### 关键指标
| 指标 | 说明 | 正常范围 |
|------|------|----------|
| **发送成功率** | 消息发送成功比例 | > 99% |
| **防骚扰拦截率** | 被拦截的骚扰消息比例 | 合理即可 |
| **响应时间** | API平均响应时间 | < 200ms |
| **并发处理** | 同时处理的消息数 | > 1000/s |

#### 监控代码示例
```java
@Component
public class PrivateMessageMetrics {
    private final MeterRegistry meterRegistry;
    
    public void recordMessageSent(int status) {
        Counter.builder("private_message.sent")
            .tag("status", String.valueOf(status))
            .register(meterRegistry)
            .increment();
    }
    
    public void recordResponseTime(Duration duration) {
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("private_message.response_time").register(meterRegistry));
    }
}
```

---

## 附录

### A. 常见问题FAQ

**Q1：为什么不直接禁止陌生人私信？**
A1：完全禁止会影响用户间正常交流，我们采用"允许一次接触，后续需建立信任"的平衡策略。

**Q2：防骚扰机制会不会误伤正常用户？**
A2：不会。正常用户发送消息后，对方回复即可建立信任关系，之后可自由聊天。

**Q3：系统支持的并发量如何？**
A3：经测试，单机可支持1000+并发消息发送，数据库优化后可线性扩展。

### B. 版本更新记录

| 版本 | 日期 | 更新内容 |
|------|------|----------|
| V2.0 | 2025-11-26 | 架构简化，用conversation表替代first_message表 |
| V1.2 | 2025-11-25 | 修复MyBatis映射错误，完善防骚扰逻辑 |
| V1.1 | 2025-11-24 | 添加conversation.created_by字段 |
| V1.0 | 2025-11-23 | 初始版本，基础私信功能 |

### C. 开发团队

| 角色 | 姓名 | 邮箱 |
|------|------|------|
| 架构师 | xu | xu@example.com |
| 后端开发 | - | - |
| 前端开发 | - | - |

---

**文档版本**：V2.0  
**最后更新**：2025-11-26  
**文档状态**：✅ 已完成
